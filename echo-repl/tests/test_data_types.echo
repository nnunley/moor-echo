// Data Type Tests

run_tests("Data Types")

// Test 1: Numbers
test("Integer operations", fn {}
  assert_eq(1 + 2, 3, "Addition")
  assert_eq(5 - 3, 2, "Subtraction")
  assert_eq(4 * 3, 12, "Multiplication")
  assert_eq(10 / 2, 5, "Division")
  assert_eq(10 % 3, 1, "Modulo")
  
  // Negative numbers
  assert_eq(-5 + 3, -2, "Negative addition")
  assert_eq(-3 * -2, 6, "Negative multiplication")
endfn)

// Test 2: Floating point
test("Float operations", fn {}
  assert_eq(1.5 + 2.5, 4.0, "Float addition")
  assert_eq(5.0 - 2.5, 2.5, "Float subtraction")
  assert_eq(2.5 * 2.0, 5.0, "Float multiplication")
  assert_eq(10.0 / 4.0, 2.5, "Float division")
  
  // Mixed int/float
  assert_eq(5 + 2.5, 7.5, "Int + Float")
  assert_eq(10.0 - 3, 7.0, "Float - Int")
endfn)

// Test 3: Strings
test("String operations", fn {}
  assert_eq("Hello" + " " + "World", "Hello World", "String concatenation")
  assert_eq("Echo" + "!", "Echo!", "String concat 2")
  
  // String with numbers
  assert_eq("Number: " + 42, "Number: 42", "String + number")
  assert_eq("Value: " + 3.14, "Value: 3.14", "String + float")
endfn)

// Test 4: Booleans
test("Boolean values", fn {}
  assert_true(true, "true is true")
  assert_false(false, "false is false")
  assert_eq(true == true, true, "true equals true")
  assert_eq(false == false, true, "false equals false")
  assert_eq(true == false, false, "true not equal false")
endfn)

// Test 5: Lists
test("List operations", fn {}
  let list = [1, 2, 3, 4, 5]
  let sum = 0
  for x in list
    sum = sum + x
  endfor
  assert_eq(sum, 15, "List iteration")
  
  // Mixed type list
  let mixed = [1, "two", 3.0, true]
  let count = 0
  for item in mixed
    count = count + 1
  endfor
  assert_eq(count, 4, "Mixed list has 4 elements")
  
  // Empty list
  let empty = []
  count = 0
  for x in empty
    count = count + 1
  endfor
  assert_eq(count, 0, "Empty list iteration")
endfn)

// Test 6: Type coercion in comparisons
test("Type comparisons", fn {}
  assert_true(5 == 5, "Int == Int")
  assert_true(5.0 == 5.0, "Float == Float")
  assert_true(5 == 5.0, "Int == Float")
  assert_true(5.0 == 5, "Float == Int")
  
  assert_false(5 == "5", "Number != String")
  assert_false("true" == true, "String != Boolean")
endfn)

// Test 7: Variables and scoping
test("Variable scoping", fn {}
  let outer = 10
  let result = 0
  
  if true
    let inner = 20
    result = outer + inner
  endif
  
  assert_eq(result, 30, "Inner scope can access outer")
  
  // Variable shadowing
  let x = 5
  if true
    let x = 10
    assert_eq(x, 10, "Inner x shadows outer")
  endif
  assert_eq(x, 5, "Outer x unchanged")
endfn)

// Test 8: Constants
test("Const bindings", fn {}
  const PI = 3.14159
  assert_eq(PI, 3.14159, "Const value")
  
  // This would error if we could test it:
  // PI = 3.14  // Error: Cannot reassign const
  
  // Const in expressions
  const FACTOR = 10
  let result = 5 * FACTOR
  assert_eq(result, 50, "Const in expression")
endfn)

test_summary()